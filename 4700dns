#!/usr/bin/env -S python3 -u

import sys
import socket
import argparse
import time
import select
import threading
import struct
from dnslib import *

# config
ROOT_IP = "1.2.3.4"
BIND_PORT = 0
ZONE_FILE = "example.com.zone"
UPSTREAM_PORT = 60053
TIMEOUT = 5.0

# zone data
MY_ORIGIN = ""
MY_RECORDS = []

# cache
CACHE = {}
CACHE_LOCK = threading.Lock()

def log(msg):
    pass

# utils

def dedup(target, new_rrs):
    # merge unique
    for r in new_rrs:
        exists = False
        for t in target:
            if r.rname == t.rname and r.rtype == t.rtype and r.rdata == t.rdata:
                exists = True
                break
        if not exists:
            target.append(r)

# cache sys

class Mem:
    def __init__(self):
        self.d = {}

    def add(self, rrs):
        with CACHE_LOCK:
            now = time.time()
            for r in rrs:
                if not r.rdata: continue
                # key
                k = (str(r.rname).lower(), r.rtype, str(r.rdata))
                self.d[k] = (now + r.ttl, r)

    def get(self, n, t):
        with CACHE_LOCK:
            now = time.time()
            ret = []
            kill = []
            n = str(n).lower()

            for k, (exp, rec) in self.d.items():
                kn, kt, _ = k
                if now > exp:
                    kill.append(k)
                    continue

                if kn == n:
                    if kt == t or t == QTYPE.ANY or kt == QTYPE.CNAME:
                        left = int(exp - now)
                        ret.append(RR(rec.rname, rec.rtype, rec.rclass, left, rec.rdata))

            for k in kill:
                del self.d[k]
            return ret

mem = Mem()

# zone ops

def load():
    global MY_ORIGIN, MY_RECORDS
    try:
        with open(ZONE_FILE, 'r') as f:
            MY_RECORDS = list(RR.fromZone(f.read()))
            for r in MY_RECORDS:
                if r.rtype == QTYPE.SOA:
                    MY_ORIGIN = str(r.rname).lower()
    except:
        sys.exit(1)

def get_glue(n):
    g = []
    t = str(n).lower()
    for r in MY_RECORDS:
        if str(r.rname).lower() == t and r.rtype in [QTYPE.A, QTYPE.AAAA]:
            g.append(r)
    return g

def local_look(qn, qt):
    ans = []
    add = []
    qs = str(qn).lower()

    # scan
    for r in MY_RECORDS:
        if str(r.rname).lower() == qs:
            if r.rtype == qt or qt == QTYPE.ANY:
                ans.append(r)
                if r.rtype in [QTYPE.NS, QTYPE.MX]:
                    add.extend(get_glue(r.rdata))
            elif r.rtype == QTYPE.CNAME:
                ans.append(r)

    # recurse cname
    if ans and ans[0].rtype == QTYPE.CNAME and qt != QTYPE.CNAME:
        tgt = str(ans[0].rdata)
        sa, _, sa_add = local_look(tgt, qt)
        ans.extend(sa)
        add.extend(sa_add)

    return ans, [], add

# net

def is_sub(c, p):
    p = str(p).lower().strip('.')
    if not p: return True
    c = str(c).lower().strip('.')
    return c == p or c.endswith('.' + p)

def tx(ip, p):
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.setblocking(0)
    dst = (ip, UPSTREAM_PORT)
    raw = p.pack()

    for _ in range(4):
        try:
            s.sendto(raw, dst)
            r, _, _ = select.select([s], [], [], 2.0)
            if r:
                d, _ = s.recvfrom(65535)
                s.close()
                return DNSRecord.parse(d)
        except:
            pass
    s.close()
    return None

# resolution

def recursive(qn, qt):
    # return (rcode, ans, auth, add)

    # cache check
    hit = mem.get(qn, qt)
    if hit:
        found = any(r.rtype == qt for r in hit)

        # glue fetch
        glue_recs = []
        for r in hit:
            if r.rtype in [QTYPE.NS, QTYPE.MX]:
                g = mem.get(str(r.rdata), QTYPE.A)
                if g: glue_recs.extend(g)

        if found or qt == QTYPE.CNAME:
            return RCODE.NOERROR, hit, [], glue_recs

    dst = ROOT_IP
    scope = "."

    out_ans = []
    out_auth = []
    out_add = []

    curr = qn

    for _ in range(15):
        req = DNSRecord(q=DNSQuestion(curr, qt))
        res = tx(dst, req)

        if not res: return RCODE.SERVFAIL, [], [], []

        # filters
        ok_rr = [r for r in res.rr if is_sub(r.rname, scope)]
        ok_auth = [r for r in res.auth if is_sub(r.rname, scope)]
        ok_ar = [r for r in res.ar if is_sub(r.rname, scope)]

        mem.add(ok_rr + ok_auth + ok_ar)

        # found answer
        if ok_rr:
            dedup(out_ans, ok_rr)
            out_auth = ok_auth
            out_add = ok_ar

            # types
            got_type = any(r.rtype == qt for r in out_ans if str(r.rname).lower() == str(curr).lower())
            if got_type or qt == QTYPE.CNAME:
                return RCODE.NOERROR, out_ans, out_auth, out_add

            # cname chain
            cname_rr = next((r for r in out_ans if r.rtype == QTYPE.CNAME and str(r.rname).lower() == str(curr).lower()), None)
            if cname_rr:
                tgt = str(cname_rr.rdata)
                # already have it?
                have_tgt = any(str(r.rname).lower() == tgt.lower() for r in out_ans)
                if not have_tgt:
                    curr = tgt
                    dst = ROOT_IP
                    scope = "."
                    continue
                else:
                    curr = tgt
                    continue

            return RCODE.NOERROR, out_ans, out_auth, out_add

        # referrals
        ns_list = [r for r in ok_auth if r.rtype == QTYPE.NS]
        if ns_list:
            ref = ns_list[0]
            scope = str(ref.rname)
            ns_str = str(ref.rdata)

            glue = [r for r in ok_ar if str(r.rname).lower() == ns_str.lower() and r.rtype == QTYPE.A]

            # loop protect
            if res.header.aa:
                # authoritative but answer in auth section?
                if qt == QTYPE.NS:
                    return RCODE.NOERROR, [], ok_auth, ok_ar
                return RCODE.NOERROR, [], ok_auth, ok_ar

            if glue:
                new_dst = str(glue[0].rdata)
                if new_dst == dst:
                    # loop detected
                    return RCODE.SERVFAIL, [], [], []
                dst = new_dst
            else:
                # resolve ns
                rc, nr, _, _ = recursive(ns_str, QTYPE.A)
                if rc == RCODE.NOERROR and nr and nr[0].rtype == QTYPE.A:
                    new_dst = str(nr[0].rdata)
                    if new_dst == dst: return RCODE.SERVFAIL, [], [], []
                    dst = new_dst
                else:
                    return RCODE.SERVFAIL, [], [], []
            continue

        if res.header.rcode == RCODE.NXDOMAIN:
            return RCODE.NXDOMAIN, [], ok_auth, []

        return RCODE.NOERROR, [], [], []

    return RCODE.SERVFAIL, [], [], []

# main

def handle(d, a, s):
    try:
        q = DNSRecord.parse(d)
        qn = q.q.qname
        qt = q.q.qtype

        rep = q.reply()

        if is_sub(qn, MY_ORIGIN):
            rep.header.aa = 1
            ra, _, rad = local_look(qn, qt)

            if ra:
                for x in ra: rep.add_answer(x)
                for x in rad: rep.add_ar(x)
            else:
                # exist check
                exists = False
                qs = str(qn).lower()
                for r in MY_RECORDS:
                    if str(r.rname).lower() == qs:
                        exists = True
                        break
                if not exists:
                    rep.header.rcode = RCODE.NXDOMAIN
        else:
            rep.header.aa = 0
            if not q.header.rd:
                rep.header.rcode = RCODE.REFUSED
            else:
                rc, rans, rauth, radd = recursive(qn, qt)
                rep.header.rcode = rc

                # promote ns if needed
                if qt == QTYPE.NS and not rans and rauth:
                    # check if auth has the answer
                    promoted = []
                    rem_auth = []
                    for r in rauth:
                        if r.rtype == QTYPE.NS and str(r.rname).lower() == str(qn).lower():
                            promoted.append(r)
                        else:
                            rem_auth.append(r)
                    if promoted:
                        rans = promoted
                        rauth = rem_auth

                for x in rans: rep.add_answer(x)
                for x in rauth: rep.add_auth(x)
                for x in radd: rep.add_ar(x)

        s.sendto(rep.pack(), a)
    except:
        pass

def main():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.bind(('127.0.0.1', BIND_PORT))
    print("Bound to port %d" % s.getsockname()[1], flush=True)

    while True:
        try:
            r, _, _ = select.select([s], [], [], 1.0)
            if r:
                d, a = s.recvfrom(65535)
                threading.Thread(target=handle, args=(d, a, s)).start()
        except:
            pass

if __name__ == "__main__":
    p = argparse.ArgumentParser()
    p.add_argument('--port', type=int, default=0)
    p.add_argument('root')
    p.add_argument('zone')
    args = p.parse_args()

    ROOT_IP = args.root
    ZONE_FILE = args.zone
    BIND_PORT = args.port

    load()
    main()