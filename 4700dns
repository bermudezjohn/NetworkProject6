#!/usr/bin/env -S python3 -u

import sys
import socket
import argparse
import time
import select
import threading
import struct
from dnslib import *

# settings
ROOT_IP = "1.2.3.4"
BIND_PORT = 0
ZONE_FILE = "example.com.zone"
UPSTREAM_PORT = 60053
TIMEOUT = 5.0

# global data
MY_ORIGIN = ""
MY_RECORDS = []

# cache setup
CACHE = {}
CACHE_LOCK = threading.Lock()

def log(msg):
    # logging disabled
    pass

# helper structures

class RecordCache:
    def __init__(self):
        self.data = {}

    def add(self, records):
        with CACHE_LOCK:
            now = time.time()
            for r in records:
                # store record with key
                key = (str(r.rname).lower(), r.rtype, str(r.rdata))
                self.data[key] = (now + r.ttl, r)

    def get(self, name, qtype):
        with CACHE_LOCK:
            now = time.time()
            results = []
            to_del = []
            name = str(name).lower()

            for key, (expire, rec) in self.data.items():
                k_name, k_type, _ = key
                if now > expire:
                    to_del.append(key)
                    continue

                if k_name == name:
                    if k_type == qtype or qtype == QTYPE.ANY or k_type == QTYPE.CNAME:
                        # adjust ttl
                        ttl_rem = int(expire - now)
                        results.append(RR(rec.rname, rec.rtype, rec.rclass, ttl_rem, rec.rdata))

            for k in to_del:
                del self.data[k]
            return results

cache_store = RecordCache()

# zone file handling

def load_zone(path):
    global MY_ORIGIN, MY_RECORDS
    try:
        with open(path, 'r') as f:
            MY_RECORDS = list(RR.fromZone(f.read()))
            for r in MY_RECORDS:
                if r.rtype == QTYPE.SOA:
                    MY_ORIGIN = str(r.rname).lower()
    except Exception as e:
        sys.exit(1)

def get_glue(target_name):
    # find glue records
    glues = []
    target = str(target_name).lower()
    for r in MY_RECORDS:
        if str(r.rname).lower() == target and r.rtype in [QTYPE.A, QTYPE.AAAA]:
            glues.append(r)
    return glues

def get_local_answer(qname, qtype):
    # check local zone for match
    answers = []
    additional = []
    qname_str = str(qname).lower()

    # 1. direct match check
    for r in MY_RECORDS:
        if str(r.rname).lower() == qname_str:
            if r.rtype == qtype or qtype == QTYPE.ANY:
                answers.append(r)
                # include glue if needed
                if r.rtype in [QTYPE.NS, QTYPE.MX]:
                    additional.extend(get_glue(r.rdata))
            elif r.rtype == QTYPE.CNAME:
                answers.append(r)

    # 2. handle cname chaining if needed
    if answers and answers[0].rtype == QTYPE.CNAME and qtype != QTYPE.CNAME:
        target = str(answers[0].rdata)
        sub_ans, sub_auth, sub_add = get_local_answer(target, qtype)
        answers.extend(sub_ans)
        additional.extend(sub_add)

    return answers, [], additional

# network helpers

def is_subdomain(child, parent):
    c = str(child).lower().strip('.')
    p = str(parent).lower().strip('.')
    if not p: return True
    return c == p or c.endswith('.' + p)

def send_query(ip, pkt):
    # send with retry logic
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.setblocking(0)
    dest = (ip, UPSTREAM_PORT)
    data = pkt.pack()

    for _ in range(5):
        try:
            s.sendto(data, dest)
            ready = select.select([s], [], [], 1.0)
            if ready[0]:
                resp, _ = s.recvfrom(65535)
                s.close()
                return DNSRecord.parse(resp)
        except:
            pass
    s.close()
    return None

# core resolution logic

def resolve(qname, qtype):
    # returns sections tuple

    # 1. check cache
    cached = cache_store.get(qname, qtype)
    if cached:
        has_type = any(r.rtype == qtype for r in cached)
        if not has_type and qtype != QTYPE.CNAME:
            pass
        return cached, [], []

    # 2. iterative search
    target_ns = ROOT_IP
    bailiwick = "."

    final_answers = []
    final_auth = []
    final_add = []

    curr_name = qname

    for _ in range(15):
        q = DNSRecord(q=DNSQuestion(curr_name, qtype))
        resp = send_query(target_ns, q)

        if not resp: return None

        # filter by bailiwick
        valid_rr = [r for r in resp.rr if is_subdomain(r.rname, bailiwick)]
        valid_auth = [r for r in resp.auth if is_subdomain(r.rname, bailiwick)]
        valid_ar = [r for r in resp.ar if is_subdomain(r.rname, bailiwick)]

        # update cache
        cache_store.add(valid_rr + valid_auth + valid_ar)

        # check results

        # A. answer found?
        if valid_rr:
            final_answers.extend(valid_rr)
            final_auth.extend(valid_auth)
            final_add.extend(valid_ar)

            # check cname chain
            first = valid_rr[0]
            if first.rtype == QTYPE.CNAME and qtype != QTYPE.CNAME:
                cname_target = str(first.rdata)

                have_target = any(str(x.rname).lower() == cname_target.lower() and x.rtype == qtype for x in valid_rr)

                if not have_target:
                    # continue resolving target
                    curr_name = cname_target
                    target_ns = ROOT_IP
                    bailiwick = "."
                    continue

            return final_answers, final_auth, final_add

        # B. referral found?
        ns_records = [r for r in valid_auth if r.rtype == QTYPE.NS]
        if ns_records:
            ref = ns_records[0]
            bailiwick = str(ref.rname)
            ns_name = str(ref.rdata)

            # check glue
            glue = [r for r in valid_ar if str(r.rname).lower() == ns_name.lower() and r.rtype == QTYPE.A]

            if glue:
                target_ns = str(glue[0].rdata)
            else:
                # resolve ns manually
                ns_res, _, _ = resolve(ns_name, QTYPE.A)
                if ns_res and ns_res[0].rtype == QTYPE.A:
                    target_ns = str(ns_res[0].rdata)
                else:
                    return None
            continue

        # C. nxdomain check
        if resp.header.rcode == RCODE.NXDOMAIN:
            return [], valid_auth, []

        return None

    return None

# main server loop

def worker(data, addr, sock):
    try:
        req = DNSRecord.parse(data)
        qname = req.q.qname
        qtype = req.q.qtype

        reply = req.reply()

        # check authority
        if is_subdomain(qname, MY_ORIGIN):
            reply.header.aa = 1
            ans, _, add = get_local_answer(qname, qtype)

            if ans:
                for r in ans: reply.add_answer(r)
                for r in add: reply.add_ar(r)
            else:
                # check existence
                name_exists = False
                qstr = str(qname).lower()
                for r in MY_RECORDS:
                    if str(r.rname).lower() == qstr:
                        name_exists = True
                        break

                if not name_exists:
                    reply.header.rcode = RCODE.NXDOMAIN

        # recursive mode
        else:
            if not req.header.rd:
                reply.header.rcode = RCODE.REFUSED
            else:
                result = resolve(qname, qtype)
                if result is None:
                    reply.header.rcode = RCODE.SERVFAIL
                else:
                    r_ans, r_auth, r_add = result
                    if not r_ans and not r_auth:
                        if len(r_auth) > 0: reply.header.rcode = RCODE.NXDOMAIN

                    # populate response
                    for r in r_ans: reply.add_answer(r)
                    for r in r_auth: reply.add_auth(r)
                    for r in r_add: reply.add_ar(r)

        sock.sendto(reply.pack(), addr)
    except Exception as e:
        pass

def start_server():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.bind(('127.0.0.1', BIND_PORT))
    print("Bound to port %d" % s.getsockname()[1], flush=True)

    while True:
        try:
            readable, _, _ = select.select([s], [], [], 1.0)
            if readable:
                data, addr = s.recvfrom(65535)
                threading.Thread(target=worker, args=(data, addr, s)).start()
        except:
            pass

if __name__ == "__main__":
    p = argparse.ArgumentParser()
    p.add_argument('--port', type=int, default=0)
    p.add_argument('root')
    p.add_argument('zone')
    args = p.parse_args()

    ROOT_IP = args.root
    ZONE_FILE = args.zone
    BIND_PORT = args.port

    load_zone(ZONE_FILE)
    start_server()