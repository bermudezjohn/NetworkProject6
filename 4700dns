#!/usr/bin/env -S python3 -u

import sys
import socket
import argparse
import time
import select
import threading
import struct
from dnslib import *

# settings
ROOT_IP = "1.2.3.4"
BIND_PORT = 0
ZONE_FILE = "example.com.zone"
UPSTREAM_PORT = 60053
TIMEOUT = 5.0

# zone data
MY_ORIGIN = ""
MY_RECORDS = []

# cache
CACHE = {}
CACHE_LOCK = threading.Lock()

def log(msg):
    pass

# cache class

class Mem:
    def __init__(self):
        self.d = {}

    def add(self, rrs):
        with CACHE_LOCK:
            now = time.time()
            for r in rrs:
                if not r.rdata: continue
                # unique key
                k = (str(r.rname).lower(), r.rtype, str(r.rdata))
                self.d[k] = (now + r.ttl, r)

    def get(self, n, t):
        with CACHE_LOCK:
            now = time.time()
            ret = []
            kill = []
            n = str(n).lower()

            for k, (exp, rec) in self.d.items():
                kn, kt, _ = k
                if now > exp:
                    kill.append(k)
                    continue

                if kn == n:
                    if kt == t or t == QTYPE.ANY or kt == QTYPE.CNAME:
                        left = int(exp - now)
                        # safe copy
                        ret.append(RR(rec.rname, rec.rtype, rec.rclass, left, rec.rdata))

            for k in kill:
                del self.d[k]
            return ret

mem = Mem()

# zone utils

def load():
    global MY_ORIGIN, MY_RECORDS
    try:
        with open(ZONE_FILE, 'r') as f:
            MY_RECORDS = list(RR.fromZone(f.read()))
            for r in MY_RECORDS:
                if r.rtype == QTYPE.SOA:
                    MY_ORIGIN = str(r.rname).lower()
    except:
        sys.exit(1)

def get_glue(n):
    g = []
    t = str(n).lower()
    for r in MY_RECORDS:
        if str(r.rname).lower() == t and r.rtype in [QTYPE.A, QTYPE.AAAA]:
            g.append(r)
    return g

def local_look(qn, qt):
    ans = []
    add = []
    qs = str(qn).lower()

    # search records
    for r in MY_RECORDS:
        if str(r.rname).lower() == qs:
            if r.rtype == qt or qt == QTYPE.ANY:
                ans.append(r)
                if r.rtype in [QTYPE.NS, QTYPE.MX]:
                    add.extend(get_glue(r.rdata))
            elif r.rtype == QTYPE.CNAME:
                ans.append(r)

    # cname chase
    if ans and ans[0].rtype == QTYPE.CNAME and qt != QTYPE.CNAME:
        tgt = str(ans[0].rdata)
        sa, _, sa_add = local_look(tgt, qt)
        ans.extend(sa)
        add.extend(sa_add)

    return ans, [], add

# networking

def is_sub(c, p):
    # root check
    p = str(p).lower().strip('.')
    if not p: return True
    c = str(c).lower().strip('.')
    return c == p or c.endswith('.' + p)

def tx(ip, p):
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.setblocking(0)
    dst = (ip, UPSTREAM_PORT)
    raw = p.pack()

    for _ in range(3):
        try:
            s.sendto(raw, dst)
            r, _, _ = select.select([s], [], [], 1.5)
            if r:
                d, _ = s.recvfrom(65535)
                s.close()
                return DNSRecord.parse(d)
        except:
            pass
    s.close()
    return None

# main logic

def recursive(qn, qt):
    # cache first
    hit = mem.get(qn, qt)
    if hit:
        found = any(r.rtype == qt for r in hit)
        if found or qt == QTYPE.CNAME:
            return hit, [], []

    dst = ROOT_IP
    scope = "."

    out_ans = []
    out_auth = []
    out_add = []

    curr = qn

    for _ in range(20):
        req = DNSRecord(q=DNSQuestion(curr, qt))
        res = tx(dst, req)

        if not res: return None

        # filters
        ok_rr = [r for r in res.rr if is_sub(r.rname, scope)]
        ok_auth = [r for r in res.auth if is_sub(r.rname, scope)]
        ok_ar = [r for r in res.ar if is_sub(r.rname, scope)]

        mem.add(ok_rr + ok_auth + ok_ar)

        # update authorities
        out_auth = ok_auth
        out_add = ok_ar

        # found answer?
        if ok_rr:
            for r in ok_rr:
                if r not in out_ans: out_ans.append(r)

            # check completeness
            got_type = any(r.rtype == qt for r in out_ans if str(r.rname).lower() == str(curr).lower())
            if got_type or qt == QTYPE.CNAME:
                return out_ans, out_auth, out_add

            # cname loop
            cname_rr = next((r for r in out_ans if r.rtype == QTYPE.CNAME and str(r.rname).lower() == str(curr).lower()), None)
            if cname_rr:
                tgt = str(cname_rr.rdata)
                have_tgt = any(str(r.rname).lower() == tgt.lower() for r in out_ans)
                if not have_tgt:
                    curr = tgt
                    dst = ROOT_IP
                    scope = "."
                    continue
                else:
                    curr = tgt
                    continue

            return out_ans, out_auth, out_add

        # referral
        ns_list = [r for r in ok_auth if r.rtype == QTYPE.NS]
        if ns_list:
            ref = ns_list[0]
            scope = str(ref.rname)
            ns_str = str(ref.rdata)

            glue = [r for r in ok_ar if str(r.rname).lower() == ns_str.lower() and r.rtype == QTYPE.A]

            if glue:
                dst = str(glue[0].rdata)
            else:
                nr, _, _ = recursive(ns_str, QTYPE.A)
                if nr and nr[0].rtype == QTYPE.A:
                    dst = str(nr[0].rdata)
                else:
                    return None
            continue

        # bailiwick empty case or nxdomain
        if res.header.rcode == RCODE.NXDOMAIN:
            return [], ok_auth, []

        # no answer, no referral, no error = probably empty due to bailiwick
        # return what we have (empty) to avoid servfail
        return [], [], []

    return None

# handler

def handle(d, a, s):
    try:
        q = DNSRecord.parse(d)
        qn = q.q.qname
        qt = q.q.qtype

        rep = q.reply()

        if is_sub(qn, MY_ORIGIN):
            rep.header.aa = 1
            ra, _, rad = local_look(qn, qt)

            if ra:
                for x in ra: rep.add_answer(x)
                for x in rad: rep.add_ar(x)
            else:
                exists = False
                qs = str(qn).lower()
                for r in MY_RECORDS:
                    if str(r.rname).lower() == qs:
                        exists = True
                        break
                if not exists:
                    rep.header.rcode = RCODE.NXDOMAIN
        else:
            rep.header.aa = 0
            if not q.header.rd:
                rep.header.rcode = RCODE.REFUSED
            else:
                ret = recursive(qn, qt)
                if ret is None:
                    rep.header.rcode = RCODE.SERVFAIL
                else:
                    rans, rauth, radd = ret
                    if not rans and not rauth:
                        if len(rauth) > 0: rep.header.rcode = RCODE.NXDOMAIN

                    for x in rans: rep.add_answer(x)
                    for x in rauth: rep.add_auth(x)
                    for x in radd: rep.add_ar(x)

        s.sendto(rep.pack(), a)
    except:
        pass

def main():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.bind(('127.0.0.1', BIND_PORT))
    print("Bound to port %d" % s.getsockname()[1], flush=True)

    while True:
        try:
            r, _, _ = select.select([s], [], [], 1.0)
            if r:
                d, a = s.recvfrom(65535)
                threading.Thread(target=handle, args=(d, a, s)).start()
        except:
            pass

if __name__ == "__main__":
    p = argparse.ArgumentParser()
    p.add_argument('--port', type=int, default=0)
    p.add_argument('root')
    p.add_argument('zone')
    args = p.parse_args()

    ROOT_IP = args.root
    ZONE_FILE = args.zone
    BIND_PORT = args.port

    load()
    main()