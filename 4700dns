#!/usr/bin/env -S python3 -u

import sys
import socket
import argparse
import time
import select
import threading
import struct
from dnslib import *

# config
ROOT_IP = "1.2.3.4"
BIND_PORT = 0
ZONE_FILE = "example.com.zone"
UPSTREAM_PORT = 60053
TIMEOUT = 5.0

# zone data
MY_ORIGIN = ""
MY_RECORDS = []

# storage
CACHE = {}
CACHE_LOCK = threading.Lock()

def log(msg):
    # no logs
    pass

# storage class

class RecordCache:
    def __init__(self):
        self.data = {}

    def add(self, records):
        with CACHE_LOCK:
            now = time.time()
            for r in records:
                # store unique key
                key = (str(r.rname).lower(), r.rtype, str(r.rdata))
                self.data[key] = (now + r.ttl, r)

    def get(self, name, qtype):
        with CACHE_LOCK:
            now = time.time()
            results = []
            to_del = []
            name = str(name).lower()

            for key, (expire, rec) in self.data.items():
                k_name, k_type, _ = key
                if now > expire:
                    to_del.append(key)
                    continue

                # match logic
                if k_name == name:
                    if k_type == qtype or qtype == QTYPE.ANY or k_type == QTYPE.CNAME:
                        ttl_rem = int(expire - now)
                        # copy record
                        results.append(RR(rec.rname, rec.rtype, rec.rclass, ttl_rem, rec.rdata))

            for k in to_del:
                del self.data[k]
            return results

cache_store = RecordCache()

# loader

def load_zone(path):
    global MY_ORIGIN, MY_RECORDS
    try:
        with open(path, 'r') as f:
            MY_RECORDS = list(RR.fromZone(f.read()))
            for r in MY_RECORDS:
                if r.rtype == QTYPE.SOA:
                    MY_ORIGIN = str(r.rname).lower()
    except Exception as e:
        sys.exit(1)

def get_glue(target_name):
    # helper for glue
    glues = []
    target = str(target_name).lower()
    for r in MY_RECORDS:
        if str(r.rname).lower() == target and r.rtype in [QTYPE.A, QTYPE.AAAA]:
            glues.append(r)
    return glues

def get_local_answer(qname, qtype):
    # find local matches
    answers = []
    additional = []
    qname_str = str(qname).lower()

    # 1. search records
    for r in MY_RECORDS:
        if str(r.rname).lower() == qname_str:
            if r.rtype == qtype or qtype == QTYPE.ANY:
                answers.append(r)
                # check glue
                if r.rtype in [QTYPE.NS, QTYPE.MX]:
                    additional.extend(get_glue(r.rdata))
            elif r.rtype == QTYPE.CNAME:
                answers.append(r)

    # 2. cname expansion
    if answers and answers[0].rtype == QTYPE.CNAME and qtype != QTYPE.CNAME:
        target = str(answers[0].rdata)
        sub_ans, sub_auth, sub_add = get_local_answer(target, qtype)
        answers.extend(sub_ans)
        additional.extend(sub_add)

    return answers, [], additional

# checks

def is_subdomain(child, parent):
    c = str(child).lower().strip('.')
    p = str(parent).lower().strip('.')
    if not p: return True
    return c == p or c.endswith('.' + p)

def send_query(ip, pkt):
    # network op
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.setblocking(0)
    dest = (ip, UPSTREAM_PORT)
    data = pkt.pack()

    for _ in range(5):
        try:
            s.sendto(data, dest)
            ready = select.select([s], [], [], 1.0)
            if ready[0]:
                resp, _ = s.recvfrom(65535)
                s.close()
                return DNSRecord.parse(resp)
        except:
            pass
    s.close()
    return None

# resolution

def resolve(qname, qtype):
    # main logic

    # 1. cache check
    cached = cache_store.get(qname, qtype)
    if cached:
        # check if incomplete cname
        has_type = any(r.rtype == qtype for r in cached)
        if not has_type and qtype != QTYPE.CNAME:
            pass
        else:
            return cached, [], []

    # 2. recursion
    target_ns = ROOT_IP
    bailiwick = "."

    final_ans = []
    final_auth = []
    final_add = []

    curr_name = qname

    # protection loop
    for _ in range(10):
        # per-name loop
        found_step_answer = False

        for _ in range(15):
            q = DNSRecord(q=DNSQuestion(curr_name, qtype))
            resp = send_query(target_ns, q)

            if not resp: return None

            # filtering
            valid_rr = [r for r in resp.rr if is_subdomain(r.rname, bailiwick)]
            valid_auth = [r for r in resp.auth if is_subdomain(r.rname, bailiwick)]
            valid_ar = [r for r in resp.ar if is_subdomain(r.rname, bailiwick)]

            cache_store.add(valid_rr + valid_auth + valid_ar)

            # case A: answer
            if valid_rr:
                final_ans.extend(valid_rr)
                # save context
                final_auth = valid_auth
                final_add = valid_ar
                found_step_answer = True
                break

            # case B: referral
            ns_records = [r for r in valid_auth if r.rtype == QTYPE.NS]
            if ns_records:
                ref = ns_records[0]
                bailiwick = str(ref.rname)
                ns_name = str(ref.rdata)

                # glue check
                glue = [r for r in valid_ar if str(r.rname).lower() == ns_name.lower() and r.rtype == QTYPE.A]

                if glue:
                    target_ns = str(glue[0].rdata)
                else:
                    # sub-query
                    ns_res, _, _ = resolve(ns_name, QTYPE.A)
                    if ns_res and ns_res[0].rtype == QTYPE.A:
                        target_ns = str(ns_res[0].rdata)
                    else:
                        return None
                continue

            # case C: error
            if resp.header.rcode == RCODE.NXDOMAIN:
                return [], valid_auth, []

            return None # unexpected

        if not found_step_answer:
            return None

        # handle chaining
        # check if we have the final type
        has_final = any(r.rtype == qtype for r in final_ans if str(r.rname).lower() == str(qname).lower())
        if has_final or qtype == QTYPE.CNAME:
            return final_ans, final_auth, final_add

        # check if we have a cname to chase
        last_rr = final_ans[-1]
        if last_rr.rtype == QTYPE.CNAME:
            target = str(last_rr.rdata)
            # check if already in packet
            already_here = any(str(r.rname).lower() == target.lower() for r in final_ans)
            if not already_here:
                curr_name = target
                target_ns = ROOT_IP
                bailiwick = "."
                continue

        return final_ans, final_auth, final_add

    return None

# server routine

def worker(data, addr, sock):
    try:
        req = DNSRecord.parse(data)
        qname = req.q.qname
        qtype = req.q.qtype

        reply = req.reply()

        # local vs recursive
        if is_subdomain(qname, MY_ORIGIN):
            reply.header.aa = 1
            ans, _, add = get_local_answer(qname, qtype)

            if ans:
                for r in ans: reply.add_answer(r)
                for r in add: reply.add_ar(r)
            else:
                # check existence
                name_exists = False
                qstr = str(qname).lower()
                for r in MY_RECORDS:
                    if str(r.rname).lower() == qstr:
                        name_exists = True
                        break

                if not name_exists:
                    reply.header.rcode = RCODE.NXDOMAIN

        else:
            if not req.header.rd:
                reply.header.rcode = RCODE.REFUSED
            else:
                result = resolve(qname, qtype)
                if result is None:
                    reply.header.rcode = RCODE.SERVFAIL
                else:
                    r_ans, r_auth, r_add = result
                    if not r_ans and not r_auth:
                        # pass through error state
                        if len(r_auth) > 0: reply.header.rcode = RCODE.NXDOMAIN

                    # build packet
                    for r in r_ans: reply.add_answer(r)
                    for r in r_auth: reply.add_auth(r)
                    for r in r_add: reply.add_ar(r)

        sock.sendto(reply.pack(), addr)
    except Exception as e:
        pass

def start_server():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.bind(('127.0.0.1', BIND_PORT))
    print("Bound to port %d" % s.getsockname()[1], flush=True)

    while True:
        try:
            readable, _, _ = select.select([s], [], [], 1.0)
            if readable:
                data, addr = s.recvfrom(65535)
                threading.Thread(target=worker, args=(data, addr, s)).start()
        except:
            pass

if __name__ == "__main__":
    p = argparse.ArgumentParser()
    p.add_argument('--port', type=int, default=0)
    p.add_argument('root')
    p.add_argument('zone')
    args = p.parse_args()

    ROOT_IP = args.root
    ZONE_FILE = args.zone
    BIND_PORT = args.port

    load_zone(ZONE_FILE)
    start_server()